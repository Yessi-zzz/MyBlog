{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\u4f60\u597d","text":""},{"location":"DP/","title":"Index","text":"","tags":["DP"]},{"location":"DP/#properties","title":"Properties","text":"<ul> <li>A recursive solution that has repeated calls for the same inputs.</li> <li>The idea is to simply store the results of subproblems so that we do not have to re-compute them when needed later. This simple optimization typically reduces time complexities from exponential to polynomial.</li> </ul>","tags":["DP"]},{"location":"DP/#when-to-use-dynamic-programming-dp","title":"When to Use Dynamic Programming (DP)?","text":"<p>^92e7f9 1.  Optimal Substructure</p> <p>[!example]+ The minimum cost path Consider the problem of finding the minimum cost path in a weighted graph from a source node to a destination node. We can break this problem down into smaller subproblems: - Find the minimum cost path from the source node to each intermediate node. - Find the minimum cost path from each intermediate node to the destination node.</p> <p>The solution to the larger problem (finding the minimum cost path from the source node to the destination node) can be constructed from the solutions to these smaller subproblems.</p> <ol> <li>Overlapping Subproblems The same subproblems are solved repeatedly in different parts of the problem refer to\u00a0Overlapping Subproblems Property in Dynamic Programming. <p>[!example]+ Fibonacci series Consider the problem of computing the Fibonacci series. To compute the Fibonacci number at index n, we need to compute the Fibonacci numbers at indices n-1 and n-2. This means that the subproblem of computing the Fibonacci number at index n-2 is used twice (note that the call for n - 1 will make two calls, one for n-2 and other for n-3) in the solution to the larger problem of computing the Fibonacci number at index n.</p> </li> </ol>","tags":["DP"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/","title":"Steps to solve a DP Problem","text":"<ol> <li>Identify if it is a Dynamic programming problem.</li> <li>Decide a state expression with the Least parameters.</li> <li>Formulate state and transition relationship.</li> <li>Apply tabulation or memorization.</li> </ol>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#step-1-how-to-classify-a-problem-as-a-dynamic-programming-problem-introduction-to-dp92e7f9","title":"Step 1: How to classify a problem as a Dynamic Programming Problem? ([[Introduction to DP#^92e7f9]])","text":"<ul> <li>Typically, all the problems that require\u00a0maximizing or minimizing\u00a0certain quantities or counting problems that say to count the arrangements under certain conditions or certain probability problems can be solved by using Dynamic Programming.</li> <li>All dynamic programming problems satisfy the\u00a0overlapping subproblems\u00a0property and most of the classic Dynamic programming problems also satisfy the\u00a0optimal substructure\u00a0property. Once we observe these properties in a given problem be sure that it can be solved using Dynamic Programming.</li> </ul>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#step-2-deciding-the-state","title":"Step 2: Deciding the state","text":"<p>[!important] Dynamic Programming problems are all about the\u00a0state\u00a0and its\u00a0transition.</p>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#state","title":"state:","text":"<p>A state can be defined as the set of parameters that can uniquely identify a certain position or standing in the given problem. This set of parameters should be as small as possible to reduce state space.</p>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#example-knapsack-problem","title":"Example: [[Knapsack Problem]]","text":"<p>Here, we define our state using two parameters:\u00a0 index\u00a0and\u00a0weight\u00a0(dp[index][weight]). These two parameters work together to uniquely identify each subproblem we need to solve.</p>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#step-3-formulating-a-relation-among-the-states","title":"Step 3: Formulating a relation among the states","text":"<p>The Hardest Part: require a lot of intuition, observation, and practice</p>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#example","title":"Example:","text":"<p>Given 3 numbers {1, 3, 5}, The task is to tell the total number of ways we can form a number\u00a0n\u00a0using the\u00a0sum\u00a0of the given three numbers. (allowing repetitions and different arrangements).</p> <p>The total number of ways to form 6 is: 8 1 + 1 + 1 + 1 + 1 + 1 1 + 1 + 1 + 3 1 + 1 + 3 + 1 1 + 3 + 1 + 1 3 + 1 + 1 + 1 3 + 3 1 + 5 5 + 1</p> <p>The steps to solve the given problem will be: - Decide a state for the given problem.\u00a0 - Take a parameter\u00a0n\u00a0to decide the state as it uniquely identifies any subproblem.\u00a0 - DP state will look like\u00a0state(n); state(n) means the total number of arrangements to form\u00a0n\u00a0by using {1, 3, 5} as elements. Derive a transition relation between any two states. - Now, compute state(n).</p>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#how-to-compute-the-state","title":"How to Compute the state?","text":"<p>Assume that the result for n = 1, 2, 3, 4, 5, 6 Let us say we know the result for: state (n = 1), state (n = 2), state (n = 3) ......... state (n = 6)\u00a0 Now, we wish to know the result of the state (n = 7). we can only add 1, 3, and 5. Now we can get a sum total of 7 in the following 3 ways:</p> <p>[!important]+ Analysis 1) Adding 1 to all possible combinations of state (n = 6) Eg : [(1 + 1 + 1 + 1 + 1 + 1) + 1]\u00a0 [(1 + 1 + 1 + 3) + 1]\u00a0 [(1 + 1 + 3 + 1) + 1]\u00a0 [(1 + 3 + 1 + 1) + 1]\u00a0 [(3 + 1 + 1 + 1) + 1]\u00a0 [(3 + 3) + 1]\u00a0 [(1 + 5) + 1]\u00a0 [(5 + 1) + 1]\u00a0</p> <p>2) Adding 3 to all possible combinations of state (n = 4) [(1 + 1 + 1 + 1) + 3]\u00a0 [(1 + 3) + 3]\u00a0 [(3 + 1) + 3]\u00a0</p> <p>3) Adding 5 to all possible combinations of state(n = 2) [(1 + 1) + 5]</p> <p>(Note how it sufficient to add only on the right-side - all the add-from-left-side cases are covered, either in the same state, or another, e.g. [1 + (1 + 1 + 1 + 3)] \u00a0is not needed in state (n=6) because it's covered by state (n = 4) [(1 + 1 + 1 + 1) + 3])</p> <p>Therefore, we can say that result for\u00a0 state(7) = state (6) + state (4) + state (2)\u00a0 OR state(7) = state (7-1) + state (7-3) + state (7-5) In general,\u00a0 state(n) = state(n-1) + state(n-3) + state(n-5) </p> <pre><code># Python program to express\n# n as sum of 1, 3, 5.\n\n# Returns the number of \n# arrangements to form 'n' \ndef countWays(n):\n\n    # base case\n    if n &lt; 0:\n        return 0\n    if n == 0:\n        return 1\n\n    return countWays(n - 1) + countWays(n - 3) + countWays(n - 5)\n\nif __name__ == \"__main__\":\n    n = 7\n    print(countWays(n))\n</code></pre> <p>output: <code>12</code> Time Complexity:\u00a0O(3^n), As at every stage we need to take three decisions and the height of the tree will be of the order of n. Auxiliary Space:\u00a0O(n), The extra space is used due to the recursion call stack.</p> <p>The above code seems exponential as it is calculating the same state again and again. So, we just need to add\u00a0memoization.</p>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#step-4-adding-memoization-or-tabulation-for-the-state","title":"Step 4: Adding memoization or tabulation for the state","text":"<p>The easiest part of a dynamic programming solution: just need to store the state answer so that the next time that state is required, then directly use it from memory.</p>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#using-top-down-dp-memoization","title":"Using\u00a0Top-Down DP (Memoization)","text":"<p>Break down the problem into smaller subproblems, where each subproblem corresponds to finding the number of ways to form a sum for a smaller value of 'n'. By utilizing previously computed results, we can avoid redundant calculations and build up the solution for larger values of 'n'.</p> <pre><code># Python program to express\n# n as sum of 1, 3, 5.\n\ndef countRecur(n, memo):\n\n    # base case\n    if n &lt; 0:\n        return 0\n    if n == 0:\n        return 1\n\n    # If value is memoized\n    if memo[n] != -1:\n        return memo[n]\n\n    # Memoize the state \n    memo[n] = countRecur(n - 1, memo) + \\\n              countRecur(n - 3, memo) + \\\n              countRecur(n - 5, memo)\n\n    return memo[n]\n\n# Returns the number of \n# arrangements to form 'n' \ndef countWays(n):\n    memo = [-1] * (n + 1)\n    return countRecur(n, memo)\n\nif __name__ == \"__main__\":\n    n = 7\n    print(countWays(n))\n</code></pre> <p>output: <code>12</code> Time Complexity:\u00a0O(n), As at every stage we need to take three decisions and the height of the tree will be of the order of n. Auxiliary Space:\u00a0O(n + n), The extra space is used due to the recursion call stack and memo array of size n+1 is used to store the results of subproblems.</p>","tags":["DP","tools"]},{"location":"DP/Steps%20to%20solve%20a%20DP%20Problem/#using-bottom-up-dp-tabulation","title":"Using Bottom-Up DP (Tabulation)","text":"<p>Define a DP array where each element dp[i] represents the number of ways to form the sum 'i'. Starting with the base case dp[0] = 1 (since there is exactly one way to form a sum of 0 - using no numbers), we iteratively calculate the number of ways to form each value from 1 to n.</p> <pre><code># Python program to express\n# n as sum of 1, 3, 5.\n\n# Returns the number of \n# arrangements to form 'n' \ndef countWays(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        dp[i] = 0\n\n        if i - 1 &gt;= 0:\n            dp[i] += dp[i - 1]\n        if i - 3 &gt;= 0:\n            dp[i] += dp[i - 3]\n        if i - 5 &gt;= 0:\n            dp[i] += dp[i - 5]\n\n    return dp[n]\n\nif __name__ == \"__main__\":\n    n = 7\n    print(countWays(n))\n</code></pre> <p>output: <code>12</code> Time Complexity:\u00a0O(n), As we just need to make 3n function calls and there will be no repetitive calculations as we are returning previously calculated results. Auxiliary Space:\u00a0O(n), dp array of size n+1 is used to store the results of subproblems.</p>","tags":["DP","tools"]},{"location":"DP/Two%20approaches%20of%20DP/","title":"Two approaches to DP","text":"","tags":["DP","tools"]},{"location":"DP/Two%20approaches%20of%20DP/#memoization","title":"Memoization","text":"<ul> <li>Top-down approach</li> <li>Stores the results of function calls in a table.</li> <li>Recursive implementation</li> <li>Entries are filled when needed.</li> </ul>","tags":["DP","tools"]},{"location":"DP/Two%20approaches%20of%20DP/#tabulation","title":"Tabulation","text":"<ul> <li>Bottom-up approach</li> <li>Stores the results of subproblems in a table</li> <li>Iterative implementation</li> <li>Entries are filled in a bottom-up manner from the smallest size to the final size.</li> </ul> <p>![[Fibonacci Tree image.png]]</p> <p>[!abstract]+ Differences Memoization(Recursive): \\(F_{5}\\) to \\(F_{0}\\) and \\(F_{1}\\) Tabulation(Iterative): \\(F_{0}\\) and \\(F_{1}\\) to \\(F_{5}\\)</p>","tags":["DP","tools"]},{"location":"DP/Two%20approaches%20of%20DP/#example-rod-cutting-problem","title":"Example: [[Rod Cutting Problem]].","text":"<p>Memoization vs Tabulation ![[Contrast two approaches of DP image.png]]</p>","tags":["DP","tools"]},{"location":"Yessi/","title":"Yessi Luo","text":""},{"location":"Yessi/%E6%88%91%E7%9A%84%E7%BB%8F%E5%8E%86/","title":"\u6211\u7684\u7ecf\u5386","text":""},{"location":"Yessi/Desktop/PC/","title":"\u7535\u8111","text":""},{"location":"Yessi/Desktop/PC/#mac","title":"Mac","text":""},{"location":"Yessi/Desktop/PC/#macbook-pro-13-inch-2022","title":"MacBook Pro 13-inch 2022","text":"<ul> <li>CPU: Apple M2</li> <li>RAM: 8 GB</li> <li>Storage: Macintosh HD 256 GB</li> <li>Serial Number: LQXTHX1F00</li> <li>Displays: 13.3-inch (2560 x 1600)</li> <li>System: macOS Tahoe Version 26.1</li> </ul>"},{"location":"Yessi/Desktop/PC/#windows","title":"Windows","text":""},{"location":"Yessi/Desktop/PC/#r9000p-2025","title":"\u8054\u60f3 \u62ef\u6551\u8005 R9000P 2025","text":"<ul> <li>CPU: AMD RYZEN 9 8945HX</li> <li>RAM: \u4e09\u661f 32GB DDR5 5200MHZ (16GB + 16GB)</li> <li>Storage: UMIS RPJY1T24MML1AWY (1T)</li> <li>GPU: NVIDIA GeForce RTX 5070Ti (12GB)</li> <li>Display: NE16QDM-NZB</li> <li>System: Windows 11 \u4e13\u4e1a\u7248 / AtlasOS</li> <li>12934\u00a5</li> </ul>"},{"location":"Yessi/Desktop/accessories/","title":"\u914d\u4ef6","text":""},{"location":"Yessi/Desktop/accessories/#_1","title":"\u7535\u8111\u914d\u4ef6","text":"<ol> <li>Belkin USB-C \u4e94\u5408\u4e00\u62d3\u5c55\u575e (228\u00a5)<ul> <li>2*SD\u5361\u69fd</li> <li>2*USD 3.1\u63a5\u53e3</li> <li>1*HDMI\u63a5\u53e3</li> </ul> </li> <li>\u4e09\u661f T7sheild\u6708\u5e55\u767d \u79fb\u52a8\u56fa\u6001\u786c\u76d8 (799\u00a5)   <ul> <li>1 TB</li> <li>1000-2000Mb/s</li> <li>USB3.2</li> </ul> </li> <li>mryc Type-c \u6570\u636e\u7ebf (59\u00a5) + \u82f9\u679cPD\u7535\u6e90\u9002\u914d\u5668</li> </ol>"},{"location":"Yessi/Desktop/clothes/","title":"\u7a7f\u642d","text":""},{"location":"Yessi/Desktop/clothes/#_1","title":"\u79cb","text":""},{"location":"Yessi/Desktop/clothes/#_2","title":"\u51ac","text":""},{"location":"Yessi/Desktop/clothes/#_3","title":"\u6ed1\u96ea","text":""},{"location":"Yessi/Desktop/clothes/#_4","title":"\u6625","text":""},{"location":"Yessi/Desktop/clothes/#_5","title":"\u590f","text":""},{"location":"Yessi/Desktop/earphone/","title":"\u8033\u673a","text":""},{"location":"Yessi/Desktop/earphone/#headphones","title":"Headphones","text":""},{"location":"Yessi/Desktop/earphone/#sony-wh-1000xm4","title":"Sony WH-1000Xm4","text":"<ul> <li>\u84dd\u8272</li> <li>Type-C \u63a5\u53e3</li> <li>\u65e0\u9632\u6c34\u7b49\u7ea7</li> <li>\u964d\u566a\u6548\u679c\u597d, \u53ef\u7528\u4e8e\u56fe\u4e66\u9986\u7b49</li> <li>1799\u00a5</li> </ul>"},{"location":"Yessi/Desktop/earphone/#2","title":"\u98d3\u98ce2","text":"<ul> <li>\u9ed1\u7ea2</li> <li>\u6709\u7ebf, 3.5mm+USB</li> <li>\u542b\u9ea6\u514b\u98ce</li> <li>469\u00a5</li> </ul>"},{"location":"Yessi/Desktop/earphone/#in-ear-headphones","title":"In-ear Headphones","text":""},{"location":"Yessi/Desktop/earphone/#1more","title":"1more \u4e09\u5355\u5143\u5708\u94c1\u8033\u673a","text":"<ul> <li>\u91d1\u8272</li> <li>\u6709\u7ebf</li> <li>L\u578b\u63d2\u5934(\u9002\u7528\u4e8eMac)</li> <li>469\u00a5</li> </ul>"},{"location":"Yessi/Desktop/earphone/#ultra","title":"\u5f31\u6c34\u65f6\u7802 \u7409\u7483Ultra","text":"<ul> <li>\u661f\u4e91\u7070</li> <li>11h \u7eed\u822a</li> <li>\u964d\u566a\u4e0d\u9519, \u6709\u98ce\u566a, \u9002\u7528\u4e8e\u901a\u52e4\u7b49</li> <li>\u9ed1\u8272\u5e7d\u7075 \u4fdd\u62a4\u58f3 (40.5\u00a5)</li> <li>215\u00a5</li> </ul>"},{"location":"Yessi/Desktop/everyday%20items/","title":"\u65e5\u5e38\u4f7f\u7528","text":""},{"location":"Yessi/Desktop/everyday%20items/#_1","title":"\u684c\u9762\u9648\u8bbe","text":""},{"location":"Yessi/Desktop/everyday%20items/#_2","title":"\u624b\u8868","text":"<ul> <li>HUAWEI WATCH GT 3 Pro</li> </ul>"},{"location":"Yessi/Desktop/everyday%20items/#_3","title":"\u5305","text":""},{"location":"Yessi/Desktop/everyday%20items/#_4","title":"\u53cc\u80a9\u5305","text":""},{"location":"Yessi/Desktop/everyday%20items/#tomtoc-x","title":"tomtoc x \u5409\u8003\u65af\u5de5\u4e1a","text":"<ul> <li>319\u00a5</li> <li>\u5145\u7535\u5b9d: ROMOSS 27000\u6beb\u5b89 65W \u53ef\u4e0a\u98de\u673a (179\u00a5)</li> </ul>"},{"location":"Yessi/Desktop/everyday%20items/#_5","title":"\u624b\u63d0\u5305","text":""},{"location":"Yessi/Desktop/everyday%20items/#tomtoc-14-inch","title":"tomtoc 14-inch","text":"<ul> <li>158\u00a5</li> <li>\u62d3\u5c55\u575e: Belkin USB-C</li> <li>\u79fb\u52a8\u56fa\u6001: \u4e09\u661f T7sheild\u6708\u5e55\u767d</li> <li>\u8033\u673a: 1more</li> </ul>"},{"location":"Yessi/Desktop/everyday%20items/#_6","title":"\u659c\u630e\u5305","text":""},{"location":"Yessi/Desktop/everyday%20items/#_7","title":"\u884c\u674e\u7bb1","text":""},{"location":"Yessi/Desktop/game%26eqs/","title":"\u6e38\u620f&\u5916\u8bbe","text":""},{"location":"Yessi/Desktop/game%26eqs/#_1","title":"\u6e38\u620f\u8bbe\u5907","text":""},{"location":"Yessi/Desktop/game%26eqs/#nintendo","title":"Nintendo","text":""},{"location":"Yessi/Desktop/game%26eqs/#ns-oled","title":"NS Oled","text":""},{"location":"Yessi/Desktop/game%26eqs/#ns-lite","title":"NS lite","text":""},{"location":"Yessi/Desktop/game%26eqs/#_2","title":"\u6e38\u620f\u76d8","text":"<ul> <li>\u5b9d\u53ef\u68a6 \u963f\u5c14\u5b99\u65af</li> <li>\u5b9d\u53ef\u68a6 \u5251\u76fe</li> <li>\u5b9d\u53ef\u68a6 \u6731\u7d2b</li> <li>\u5b9d\u53ef\u68a6 Z-A</li> <li>\u585e\u5c14\u8fbe\u4f20\u8bf4 \u8352\u91ce\u4e4b\u606f</li> <li>\u585e\u5c14\u8fbe\u4f20\u8bf4 \u738b\u56fd\u4e4b\u6cea</li> </ul>"},{"location":"Yessi/Desktop/game%26eqs/#_3","title":"\u6e38\u620f\u5916\u8bbe","text":""},{"location":"Yessi/Desktop/game%26eqs/#_4","title":"\u9f20\u6807","text":""},{"location":"Yessi/Desktop/game%26eqs/#mchose-k7-ultra","title":"MCHOSE K7 Ultra","text":"<ul> <li>\u65e0\u7ebf8K</li> <li>\u9a71\u52a8\u4e0b\u8f7d</li> <li>360\u00a5</li> <li>\u9f20\u6807\u57ab: MCHOSE \u71c3Pro(79\u00a5)</li> </ul>"},{"location":"Yessi/Desktop/game%26eqs/#vgn-f1-promax","title":"VGN F1 ProMax","text":"<ul> <li>\u65e0\u7ebf2.4G</li> <li>\u9a71\u52a8\u4e0b\u8f7d</li> <li>239\u00a5</li> <li>\u9f20\u6807\u57ab: D-GlOW(228\u00a5)</li> </ul>"},{"location":"Yessi/Desktop/game%26eqs/#_5","title":"\u952e\u76d8","text":""},{"location":"Yessi/Desktop/game%26eqs/#atk68","title":"ATK68","text":"<ul> <li>\u9a71\u52a8\u4e0b\u8f7d</li> <li>599\u00a5</li> </ul>"},{"location":"Yessi/Desktop/game%26eqs/#_6","title":"\u624b\u67c4","text":""},{"location":"Yessi/Desktop/game%26eqs/#4-pro","title":"\u98de\u667a \u9ed1\u6b66\u58eb4 Pro","text":"<ul> <li>\u9002\u7528\u5e73\u53f0: PC, SWITCH</li> <li>\u9a71\u52a8\u4e0b\u8f7d</li> <li>341\u00a5</li> </ul>"},{"location":"Yessi/Desktop/phone/","title":"\u624b\u673a&\u5e73\u677f","text":""},{"location":"Yessi/Desktop/phone/#android","title":"Android","text":""},{"location":"Yessi/Desktop/phone/#huawei-mate-60-pro","title":"HUAWEI Mate 60 Pro","text":"<ul> <li>Memory: 12 GB</li> <li>Displays: 2720 x 1260</li> <li>Storage: 512 GB</li> <li>System: HarmonyOS Version 4.2.0 (\u5df2\u5b89\u88c5\u8c37\u6b4c\u6846\u67b6)</li> </ul>"},{"location":"Yessi/Desktop/phone/#ios","title":"IOS","text":""},{"location":"Yessi/Desktop/phone/#ipad-pro-129-inch5th-generation","title":"iPad Pro (12.9-inch)(5th generation)","text":"<ul> <li>Chips: M1</li> <li>Storage: 128 GB</li> <li>System: iPadOS Version 18.7.1</li> </ul>"},{"location":"Yessi/Desktop/shooting%20eqs/","title":"\u62cd\u6444\u8bbe\u5907","text":""},{"location":"Yessi/Desktop/shooting%20eqs/#_1","title":"\u5f55\u50cf\u8bbe\u5907","text":""},{"location":"Yessi/Desktop/shooting%20eqs/#pocket3","title":"\u5927\u7586 Pocket3","text":"<ul> <li>\u5145\u7535\u624b\u67c4: LKTOP 5000\u6beb\u5b89 (159\u00a5)</li> <li>\u8bfb\u5361\u5668: \u7eff\u8054 USB/Type-C 3.0 SD/TF \u53cc\u5361\u9002\u7528 (40\u00a5)</li> <li>\u6536\u7eb3\u5305: \u7ebd\u5c14 (42\u00a5)</li> <li>\u78c1\u5438\u652f\u67b6: BRDRC (150\u00a5) &amp; \u5438\u76d8 (50\u00a5)</li> <li>\u6ee4\u955c\u5957\u88c5: \u7ebd\u5c14 (187\u00a5)</li> <li>\u62d3\u5c55\u5e95\u5ea7: \u4f18\u7bee\u5b50 PK-10 (87\u00a5)</li> </ul>"},{"location":"blog/","title":"Blog","text":"<p>\u70b9\u51fb\u5de6\u4fa7\u76ee\u5f55\u6253\u5f00\u6587\u7ae0</p>"},{"location":"notes/","title":"Notes","text":"<p>\u70b9\u51fb\u5de6\u4fa7\u76ee\u5f55\u6253\u5f00\u6587\u7ae0</p>"},{"location":"notes/codes/Fibonacci%20Number/","title":"Finbonacci Sequence","text":"<p>Recurrence relation:</p> <ul> <li>Base case: F(n) = n, when n = 0 or n = 1</li> <li>Recursive case: F(n) = F(n-1) + F(n-2) for n&gt;1</li> </ul> <pre><code>def nth_fibonacci(n):\n\n    # Base case: if n is 0 or 1, return n\n    if n &lt;= 1:\n        return n\n\n    # Recursive case: sum of the two preceding Fibonacci numbers\n    return nth_fibonacci(n - 1) + nth_fibonacci(n - 2)\n\nn = 5\nresult = nth_fibonacci(n)\nprint(result)\n</code></pre> <p>output: <code>5</code> Time Complexity:\u00a0O(2n) Auxiliary Space:\u00a0O(n), due to recursion stack</p>","tags":["DP","codes","problems"]},{"location":"notes/codes/Fibonacci%20Number/#memoization-approach","title":"Memoization Approach","text":"<pre><code># Function to calculate the nth Fibonacci number using memoization\ndef nth_fibonacci_util(n, memo):\n\n    # Base case: if n is 0 or 1, return n\n    if n &lt;= 1:\n        return n\n\n    # Check if the result is already in the memo table\n    if memo[n] != -1:\n        return memo[n]\n\n    # Recursive case: calculate Fibonacci number\n    # and store it in memo\n    memo[n] = nth_fibonacci_util(n - 1, memo) + nth_fibonacci_util(n - 2, memo)\n\n    return memo[n]\n\n\n# Wrapper function that handles both initialization\n# and Fibonacci calculation\ndef nth_fibonacci(n):\n\n    # Create a memoization table and initialize with -1\n    memo = [-1] * (n + 1)\n\n    # Call the utility function\n    return nth_fibonacci_util(n, memo)\n\n\nif __name__ == \"__main__\":\n    n = 5\n    result = nth_fibonacci(n)\n    print(result)\n</code></pre> <p>output: <code>5</code> Time Complexity:\u00a0O(n), each fibonacci number is calculated only one times from 1 to n; Auxiliary Space:\u00a0O(n), due to memo table</p>","tags":["DP","codes","problems"]},{"location":"notes/codes/Fibonacci%20Number/#bottom-up-approach","title":"Bottom-Up Approach","text":"<pre><code>def nth_fibonacci(n):\n\n    # Handle the edge cases\n    if n &lt;= 1:\n        return n\n\n    # Create a list to store Fibonacci numbers\n    dp = [0] * (n + 1)\n\n    # Initialize the first two Fibonacci numbers\n    dp[0] = 0\n    dp[1] = 1\n\n    # Fill the list iteratively\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    # Return the nth Fibonacci number\n    return dp[n]\n\nn = 5\nresult = nth_fibonacci(n)\nprint(result)\n</code></pre> <p>output: <code>5</code> Time Complexity:\u00a0O(n), the loop runs from 2 to n, performing a constant amount of work per iteration. Auxiliary Space:\u00a0O(n), due to the use of an extra array to store Fibonacci numbers up to n.</p>","tags":["DP","codes","problems"]},{"location":"notes/codes/Fibonacci%20Number/#space-optimized-approach","title":"Space Optimized Approach","text":"<pre><code>def nth_fibonacci(n):\n    if n &lt;= 1:\n        return n\n\n    # To store the curr Fibonacci number\n    curr = 0\n\n    # To store the previous Fibonacci numbers\n    prev1 = 1\n    prev2 = 0\n\n    # Loop to calculate Fibonacci numbers from 2 to n\n    for i in range(2, n + 1):\n\n        # Calculate the curr Fibonacci number\n        curr = prev1 + prev2\n\n        # Update prev2 to the last Fibonacci number\n        prev2 = prev1\n\n        # Update prev1 to the curr Fibonacci number\n        prev1 = curr\n\n    return curr\n\nn = 5\nresult = nth_fibonacci(n)\nprint(result)\n</code></pre> <p>output: <code>5</code> Time Complexity:\u00a0O(n), The loop runs from 2 to n, performing constant time operations in each iteration.) Auxiliary Space:\u00a0O(1), Only a constant amount of extra space is used to store the current and two previous Fibonacci numbers.</p>","tags":["DP","codes","problems"]},{"location":"notes/codes/Fibonacci%20Number/#using-matrix-exponentiation-ologn-time-and-ologn-space","title":"Using Matrix Exponentiation - O(log(n)) time and O(log(n)) space","text":"<pre><code># Function to multiply two 2x2 matrices\ndef multiply(mat1, mat2):\n\n    # Perform matrix multiplication\n    x = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0]\n    y = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1]\n    z = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0]\n    w = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1]\n\n    # Update matrix mat1 with the result\n    mat1[0][0], mat1[0][1] = x, y\n    mat1[1][0], mat1[1][1] = z, w\n\n# Function to perform matrix exponentiation\ndef matrix_power(mat1, n):\n\n    # Base case for recursion\n    if n == 0 or n == 1:\n        return\n\n    # Initialize a helper matrix\n    mat2 = [[1, 1], [1, 0]]\n\n    # Recursively calculate mat1^(n // 2)\n    matrix_power(mat1, n // 2)\n\n    # Square the matrix mat1\n    multiply(mat1, mat1)\n\n    # If n is odd, multiply by the helper matrix mat2\n    if n % 2 != 0:\n        multiply(mat1, mat2)\n\n# Function to calculate the nth Fibonacci number\ndef nth_fibonacci(n):\n    if n &lt;= 1:\n        return n\n\n    # Initialize the transformation matrix\n    mat1 = [[1, 1], [1, 0]]\n\n    # Raise the matrix mat1 to the power of (n - 1)\n    matrix_power(mat1, n - 1)\n\n    # The result is in the top-left cell of the matrix\n    return mat1[0][0]\n\nif __name__ == \"__main__\":\n    n = 5\n    result = nth_fibonacci(n)\n    print(result)\n</code></pre>","tags":["DP","codes","problems"]},{"location":"notes/codes/Knapsack%20Problem/","title":"Knapsack Problem","text":"<p>Given\u00a0n\u00a0items where each item has some weight and profit associated with it and also given a bag with capacity\u00a0W, i.e., the bag can hold at most\u00a0W\u00a0weight in it. The task is to put the items into the bag such that the sum of profits associated with them is the maximum possible.\u00a0</p> <p>[!warning]+ Note:\u00a0 The constraint here is we can either put an item completely into the bag or cannot put it at all [It is not possible to put a part of an item into the bag].</p>","tags":["DP","codes","problems"]},{"location":"notes/codes/Knapsack%20Problem/#naive-aproach","title":"Naive Aproach","text":"<p>![[Knapsack Problem image 1.png]]</p> <p>[!warning]+ Note: The above function using recursion computes the same subproblems again and again</p>","tags":["DP","codes","problems"]},{"location":"notes/codes/Knapsack%20Problem/#better-approach-1-using-top-down-dp-memoization-on-x-w-time-and-space","title":"[Better Approach 1] Using Top-Down DP (Memoization)- O(n x W) Time and Space","text":"<p>![[Knapsack Problem image 2.png]] If we get a subproblem the first time, we can solve this problem by creating a 2-D array that can store a particular state (n, w). Now if we come across the same state (n, w) again instead of calculating it i again we can directly return its result stored in the table in constant time.</p> <pre><code># Returns the maximum value that\n# can be put in a knapsack of capacity W\ndef knapsackRec(W, val, wt, n, memo):\n\n    # Base Case\n    if n == 0 or W == 0:\n        return 0\n\n    # Check if we have previously calculated the same subproblem\n    if memo[n][W] != -1:\n        return memo[n][W]\n\n    pick = 0\n\n    # Pick nth item if it does not exceed the capacity of knapsack\n    if wt[n - 1] &lt;= W:\n        pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1, memo)\n\n    # Don't pick the nth item\n    notPick = knapsackRec(W, val, wt, n - 1, memo)\n\n    # Store the result in memo[n][W] and return it\n    memo[n][W] = max(pick, notPick)\n    return memo[n][W]\n\ndef knapsack(W, val, wt):\n    n = len(val)\n\n    # Memoization table to store the results\n    memo = [[-1] * (W + 1) for _ in range(n + 1)]\n\n    return knapsackRec(W, val, wt, n, memo)\n\nif __name__ == \"__main__\":\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n\n    print(knapsack(W, val, wt))\n</code></pre> <p>output: <code>3</code></p>","tags":["DP","codes","problems"]},{"location":"notes/codes/Knapsack%20Problem/#better-approach-2-using-bottom-up-dp-tabulation-on-x-w-time-and-space","title":"[Better Approach 2] Using Bottom-Up DP (Tabulation) - O(n x W) Time and Space","text":"<p>There are two parameters that change in the recursive solution and these parameters go from 0 to n and 0 to W. So we create a 2D dp[][] array of size (n+1) x (W+1), such that\u00a0dp[i][j]\u00a0stores the maximum value we can get using\u00a0i\u00a0items such that the knapsack capacity is\u00a0j. - We first fill the known entries when m is 0 or n is 0. - Then we fill the remaining entries using the recursive formula.</p> <p>For each item i and knapsack capacity j, we decide whether to pick the item or not. - If we don't pick the item:\u00a0dp[i][j] remains same as the previous item, that is dp[i - 1][j]. - If we pick the item:\u00a0dp[i][j] is updated to val[i] + dp[i - 1][j - wt[i]].</p> <pre><code>def knapsack(W, val, wt):\n    n = len(wt)\n    dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]\n\n    # Build table dp[][] in bottom-up manner\n    for i in range(n + 1):\n        for j in range(W + 1):\n\n            # If there is no item or the knapsack's capacity is 0\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            else:\n                pick = 0\n\n                # Pick ith item if it does not exceed the capacity of knapsack\n                if wt[i - 1] &lt;= j:\n                    pick = val[i - 1] + dp[i - 1][j - wt[i - 1]]\n\n                # Don't pick the ith item\n                notPick = dp[i - 1][j]\n\n                dp[i][j] = max(pick, notPick)\n\n    return dp[n][W]\n\nif __name__ == \"__main__\":\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n\n    print(knapsack(W, val, wt))\n</code></pre> <p>output: <code>3</code></p>","tags":["DP","codes","problems"]},{"location":"notes/codes/Knapsack%20Problem/#expected-approach-using-bottom-up-dp-space-optimized-on-x-w-time-and-ow-space","title":"[Expected Approach] Using Bottom-Up DP (Space-Optimized)\u00a0- O(n x W) Time and O(W) Space","text":"<p>For calculating the current row of the dp[] array we require only previous row, but if we start traversing the rows from right to left then it can be done with a single row only</p> <pre><code># Function to find the maximum profit\ndef knapsack(W, val, wt):\n\n    # Initializing dp list\n    dp = [0] * (W + 1)\n\n    # Taking first i elements\n    for i in range(1, len(wt) + 1):\n\n        # Starting from back, so that we also have data of\n        # previous computation of i-1 items\n        for j in range(W, wt[i - 1] - 1, -1):\n            dp[j] = max(dp[j], dp[j - wt[i - 1]] + val[i - 1])\n\n    return dp[W]\n\nif __name__ == \"__main__\":\n    val = [1, 2, 3]\n    wt = [4, 5, 1]\n    W = 4\n\n    print(knapsack(W, val, wt))\n</code></pre> <p>output:  <code>3</code></p>","tags":["DP","codes","problems"]}]}